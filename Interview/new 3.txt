import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class EvenThread extends Thread {

    private final EvenOddPrinter evenOddPrinter;

    public EvenThread(EvenOddPrinter evenOddPrinter) {s
        this.evenOddPrinter = evenOddPrinter;
    }

    @Override
    public void run() {
        try {
            while (evenOddPrinter.current <= evenOddPrinter.limit) {
                evenOddPrinter.printEven();  // Print even numbers
                Thread.sleep(2000);  // Simulate a delay of 2 seconds for even thread
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();  // Handle interruption
        }
    }
}

public class OddThread extends Thread {

    private final EvenOddPrinter evenOddPrinter;

    public OddThread(EvenOddPrinter evenOddPrinter) {
        this.evenOddPrinter = evenOddPrinter;
    }

    @Override
    public void run() {
        try {
            while (evenOddPrinter.current <= evenOddPrinter.limit) {
                evenOddPrinter.printOdd();  // Print odd numbers
                Thread.sleep(3000);  // Simulate a delay of 3 seconds for odd thread
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();  // Handle interruption
        }
    }
}



public class EvenOddPrinter {

    private final ReentrantLock lock = new ReentrantLock(true); // Fair lock
    private final Condition condition = lock.newCondition();  // Condition for managing thread synchronization
    private int limit;  // Maximum number to print (odd/even)
    private int current; // Current number to print

    public EvenOddPrinter(int num) {
        this.limit = num;
        this.current = 1;  // Start with the first odd number
    }

    // Method to print even numbers
    public void printEven() throws InterruptedException {
        lock.lock(); // Lock to ensure mutual exclusion
        try {
            while (current % 2 != 0) { // Wait until it's the even number turn
                condition.await();  // Wait until notified by odd number thread
            }
            if (current <= limit) {
                System.out.println("Even number: " + current + " | Thread name: " + Thread.currentThread().getName());
                current++;  // Increment current number
                condition.signal();  // Signal odd number thread to continue
            }
        } finally {
            lock.unlock(); // Ensure that the lock is always released
        }
    }

    // Method to print odd numbers
    public void printOdd() throws InterruptedException {
        lock.lock(); // Lock to ensure mutual exclusion
        try {
            while (current % 2 == 0) { // Wait until it's the odd number turn
                condition.await();  // Wait until notified by even number thread
            }
            if (current <= limit) {
                System.out.println("Odd number: " + current + " | Thread name: " + Thread.currentThread().getName());
                current++;  // Increment current number
                condition.signal();  // Signal even number thread to continue
            }
        } finally {
            lock.unlock(); // Ensure that the lock is always released
        }
    }
}

public class Main {

    public static void main(String[] args) {
        int limit = 10; // Set the limit for printing even and odd numbers
        EvenOddPrinter evenOddPrinter = new EvenOddPrinter(limit);

        // Create instances of EvenThread and OddThread
        EvenThread evenThread = new EvenThread(evenOddPrinter);
        OddThread oddThread = new OddThread(evenOddPrinter);

        // Start the threads
        evenThread.start();
        oddThread.start();
    }
}
