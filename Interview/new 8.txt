Given an integer n, for every positive integer i <= n, the task is to print,
------------------------------------------------------------------------------------------------------------
“FizzBuzz” if i is divisible by 3 and 5,
“Fizz” if i is divisible by 3,
“Buzz” if i is divisible by 5
“i” as a string, if none of the conditions are true.


If a number is divisible by both 3 and 5, append “FizzBuzz” into result.
If it’s only divisible by 3, append “Fizz” into result.
If it’s only divisible by 5, append “Buzz” into result.
Otherwise, append the number itself into result.


class GfG {
    static ArrayList<String> fizzBuzz(int n){
      
        ArrayList<String> res = new ArrayList<>();

        for (int i = 1; i <= n; ++i) {
          
            // Check if i is divisible by both 3 and 5
            if (i % 3 == 0 && i % 5 == 0) {
              
                // Add "FizzBuzz" to the result list
                res.add("FizzBuzz");
            }
          
            // Check if i is divisible by 3
            else if (i % 3 == 0) {
              
                // Add "Fizz" to the result list
                res.add("Fizz");
            }
          
            // Check if i is divisible by 5
            else if (i % 5 == 0) {
              
                // Add "Buzz" to the result list
                res.add("Buzz");
            }
            else {
              
                // Add the current number as a string to the
                // result list
                res.add(Integer.toString(i));
            }
        }

        return res;
    }

    public static void main(String[] args){
        int n = 20;
        ArrayList<String> res = fizzBuzz(n);
        for (String s : res) {
            System.out.print(s + " ");
        }
    }
}



"fizzbuzz" if i is divisible by 3 and 5,
"fizz" if i is divisible by 3 and not 5,
"buzz" if i is divisible by 5 and not 3, or
i if i is not divisible by 3 or 5.
//https://liverungrow.medium.com/interview-practice-problem-for-multithreading-8f3830cce844
import java.util.concurrent.Semaphore;
import java.util.function.IntConsumer;

class FizzBuzz {
    private int n;
    private Semaphore fizzSemaphore = new Semaphore(0);
    private Semaphore buzzSemaphore = new Semaphore(0);
    private Semaphore fizzBuzzSemaphore = new Semaphore(0);
    private Semaphore numberSemaphore = new Semaphore(1);

    public FizzBuzz(int n) {
        this.n = n;
    }

    public void fizz(Runnable printFizz) throws InterruptedException {
        for (int i = 3; i <= n; i += 3) {
            if (i % 5 != 0) { // Skip multiples of 5
                fizzSemaphore.acquire();
                printFizz.run();
                numberSemaphore.release();
            }
        }
    }

    public void buzz(Runnable printBuzz) throws InterruptedException {
        for (int i = 5; i <= n; i += 5) {
            if (i % 3 != 0) { // Skip multiples of 3
                buzzSemaphore.acquire();
                printBuzz.run();
                numberSemaphore.release();
            }
        }
    }

    public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {
        for (int i = 15; i <= n; i += 15) {
            fizzBuzzSemaphore.acquire();
            printFizzBuzz.run();
            numberSemaphore.release();
        }
    }

    public void number(IntConsumer printNumber) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            numberSemaphore.acquire();
            if (i % 3 == 0 && i % 5 == 0) {
                fizzBuzzSemaphore.release();
            } else if (i % 3 == 0) {
                fizzSemaphore.release();
            } else if (i % 5 == 0) {
                buzzSemaphore.release();
            } else {
                printNumber.accept(i);
                numberSemaphore.release();
            }
        }
    }
}


Hard
    Design Movie Ticket Booking System	
	Design cache	
	Design Pub-Sub Model like Kafka 	
	Design Rate Limiter

Medium	
    Print Zero Even Odd	
    Fizz Buzz Multithreaded	
	Design Bounded Blocking Queue 	
	
Hard
	The Dining Philosophers		
	Multithreaded Web Crawler


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadLocalRandom;
//https://dev.to/plainsight16/concurrency-in-java-the-dining-philosophers-problem-nko
public class DinningPhilosophers {
    static int no_of_philosophers = 5;
    static Philosopher []philosophers = new Philosopher [no_of_philosophers];
    static Chopstick []chopsticks = new Chopstick[no_of_philosophers];


    private static class Chopstick{
        public Semaphore semaphore = new Semaphore(1);
        void grabChopstick(){
            try {
                semaphore.acquire();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        void dropChopstick(){
            semaphore.release();
        }
    }
    private static class Philosopher implements Runnable{
        private int number;
        Chopstick leftChopstick;
        Chopstick rightChopstick;
        public Philosopher(int num, Chopstick left, Chopstick right){
            number = num;
            leftChopstick = left;
            rightChopstick = right;
        }
        @Override
        public void run(){
            while(true) {
                performAction(" thinks for ")
                leftChopstick.grabChopstick();
                System.out.println("Philosopher " + (number + 1) + " picks up leftChopstick");
                rightChopstick.grabChopstick();
                System.out.println("Philosopher " + (number + 1) + " picks up rightChopstick");
                performAction(" eats for ")
                leftChopstick.dropChopstick();
                System.out.println("Philosopher " + (number + 1) + " drops leftChopstick");
                rightChopstick.dropChopstick();
                System.out.println("Philosopher " + (number + 1) + " drops rightChopstick");
            }
        }
        void performAction(String action){
          try{
          int waitTime = ThreadLocalRandom.current().nextInt(0, 
          1000);
          System.out.println("Philosopher "+ (number + 1) + action 
                            + waitTime +" ms");
          }catch(InterruptedException ex){
              ex.printStackTrace();
          }
        }
    }
    public static void main(String []args){
        for (int i = 0; i < no_of_philosophers; i++){
            chopsticks[i] = new Chopstick();
        }
        ExecutorService executor = Executors.newFixedThreadPool(no_of_philosophers);
        for (int i = 0; i < no_of_philosophers; i++){
            if( i % 2 == 0)
                philosophers[i] = new Philosopher(i, chopsticks[(i + 1) % no_of_philosophers], chopsticks[i] );
            else
                philosophers[i] = new Philosopher(i, chopsticks[i], chopsticks[(i + 1) % no_of_philosophers] );

            executor.execute(philosophers[i]);
        }
    }
}






class zeroEvenOdd{
 private int num = 0;
 private Semaphore zero= new Semaphore(1);
 private Semaphore odd= new Semaphore(0);
 private Semaphore even= new Semaphore(0);
 
	 public zeroEvenOdd(int num ){
		this.num = num;
	 }
	 
	public zero(IntConsumer consumer){ 
	    boolean isOdd = true;
		for(int idx=0; idx< num; idex++){
		  zero.acquire();
		  consumer.accept(0);
		  (isOdd ? odd : even).release();
		  isOdd = !isOdd;
		}
	}
	
	public odd(IntConsumer consumer){ 
	   for(int idx=1; idx< this.num; idx++){
	      if(idx%2==1){
			  odd.acquire(); 
			  consumer.accept(i);
			  zero.release();		  
		  }
	   }
	}
	
	public even(IntConsumer consumer){ 
	    for(int idx=1; idx< this.num; idx++){
		if(idx%2==0){
			  even.acquire(); 
			  consumer.accept(i);
			  zero.release();
		  }
		}
	}

}



import java.util.LinkedList;
import java.util.Queue;

public class SharedBuffer {
    private final Queue<Integer> queue;
    private final int capacity;

    public SharedBuffer(int capacity) {
        this.queue = new LinkedList<>();
        this.capacity = capacity;
    }

    public void put(int item) {
        queue.offer(item);
    }

    public int get() {
        return queue.poll();
    }

    public boolean isFull() {
        return queue.size() == capacity;
    }

    public boolean isEmpty() {
        return queue.isEmpty();
    }
}
public class Producer implements Runnable {
    private final SharedBuffer buffer;
    private final Object lock;
    private int value = 0;

    public Producer(SharedBuffer buffer, Object lock) {
        this.buffer = buffer;
        this.lock = lock;
    }
	
	@Override
	public void run() {
		while (true) {
			try {
				produce(value++);
				Thread.sleep(500); // Simulate time taken to produce an item
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
			}
		}
	}
	
	private void produce(int i) throws InterruptedException {
		synchronized (lock) {
			while (buffer.isFull()) {
				System.out.println("Queue is full, producer is waiting...");
				lock.wait(); // Wait until the buffer has space
			}
			buffer.put(i);
			System.out.println("Produced: " + i);
			lock.notifyAll(); // Notify the consumer that an item is available
		}
	}
	
}

public class Consumer implements Runnable {
    private final SharedBuffer buffer;
    private final Object lock;

    public Consumer(SharedBuffer buffer, Object lock) {
        this.buffer = buffer;
        this.lock = lock;
    }
	
	@Override
    public void run() {
        while (true) {
            try {
                consume();
                Thread.sleep(1000); // Simulate time taken to consume an item
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
	
	private void consume() throws InterruptedException {
		synchronized (lock) {
			while (buffer.isEmpty()) {
				System.out.println("Queue is empty, consumer is waiting...");
				lock.wait(); // Wait until the buffer has items to consume
			}
			int item = buffer.get();
			System.out.println("Consumed: " + item);
			lock.notifyAll(); // Notify the producer that space is available
		}
	}
	
}


public class Main {
    public static void main(String[] args) {
        int capacity = 5;
        SharedBuffer buffer = new SharedBuffer(capacity);
        Object lock = new Object();

        Producer producer = new Producer(buffer, lock);
        Consumer consumer = new Consumer(buffer, lock);

        Thread producerThread = new Thread(producer, "Producer");
        Thread consumerThread = new Thread(consumer, "Consumer");

        producerThread.start();
        consumerThread.start();
    }
}









class DiningPhilosophers {
    private static final int NUM_PHILOSOPHERS = 5;
    Semaphore[] semaphores = new Semaphore[NUM_PHILOSOPHERS];

    public DiningPhilosophers() {
        for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
            semaphores[i] = new Semaphore(0);
        }
        semaphores[0].release(); // start with zeroth philosopher
    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopherId,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {
		//int idx = (philosopherId + 1) % NUM_PHILOSOPHERS;				   
        semaphores[philosopherId].acquire(); // acquire for current philosopher
        pickLeftFork.run();
        pickRightFork.run();
        eat.run();
        putLeftFork.run();
        putRightFork.run();
        semaphores[(philosopherId + 1) % 5].release(); // release for next philosopher
    }
}



import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class CustomClassLoader extends ClassLoader {

    private final String classPath;

    public CustomClassLoader(String classPath, ClassLoader parent) {
        super(parent);
        this.classPath = classPath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classBytes = loadClassBytes(name);
        return defineClass(name, classBytes, 0, classBytes.length);
    }

    private byte[] loadClassBytes(String className) throws ClassNotFoundException {
        String fileName = className.replace('.', File.separatorChar) + ".class";
        try {
            FileInputStream fis = new FileInputStream(classPath + File.separator + fileName);
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            int b;
            while ((b = fis.read()) != -1) {
                bos.write(b);
            }
            fis.close();
            return bos.toByteArray();
        } catch (IOException e) {
            throw new ClassNotFoundException("Class '" + className + "' not found.", e);
        }
    }

    public static void main(String[] args) {
        // Define the path to the directory containing the class files
        String classPath = "/path/to/class/files";

        // Create an instance of the custom class loader
        CustomClassLoader classLoader = new CustomClassLoader(classPath, ClassLoader.getSystemClassLoader());

        try {
            // Load the class using the custom class loader
            Class<?> myClass = classLoader.loadClass("com.example.MyClass");

            // Create an instance of the loaded class
            Object obj = myClass.newInstance();

            // Invoke methods or access fields of the loaded class
            // For example:
            // Method method = myClass.getMethod("methodName");
            // Object result = method.invoke(obj);
        } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {
            e.printStackTrace();
        }
    }
}





In the standard Spring library, LockRegistry of SpringLock offers five primary implementation options:

PassThruLockRegistry.
GemfireLockRegistry.
RedisLockRegistry.
JdbcLockRegistry.
ZookeeperLockRegistry.










// Define the base interface for request handlers
interface PurchaseApprover {
    void setNextApprover(PurchaseApprover nextApprover);
    void processRequest(PurchaseRequest request);
}

// Concrete implementation of PurchaseApprover
class Manager implements PurchaseApprover {
    private double purchasingLimit;
    private PurchaseApprover nextApprover;

    public Manager(double purchasingLimit) {
        this.purchasingLimit = purchasingLimit;
    }

    @Override
    public void setNextApprover(PurchaseApprover nextApprover) {
        this.nextApprover = nextApprover;
    }

    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() <= purchasingLimit) {
            System.out.println("Manager approved purchase of $" + request.getAmount());
        } else if (nextApprover != null) {
            nextApprover.processRequest(request);
        } else {
            System.out.println("Purchase request for $" + request.getAmount() + " exceeds approval limit.");
        }
    }
}

// Purchase request class
class PurchaseRequest {
    private double amount;

    public PurchaseRequest(double amount) {
        this.amount = amount;
    }

    public double getAmount() {
        return amount;
    }
}

public class ChainOfResponsibilityExample {
    public static void main(String[] args) {
        // Create chain of approvers
        PurchaseApprover manager = new Manager(1000);
        PurchaseApprover director = new Manager(5000);
        PurchaseApprover vp = new Manager(10000);

        // Set up the chain of responsibility
        manager.setNextApprover(director);
        director.setNextApprover(vp);

        // Process purchase requests
        manager.processRequest(new PurchaseRequest(500));
        manager.processRequest(new PurchaseRequest(2500));
        manager.processRequest(new PurchaseRequest(7500));
        manager.processRequest(new PurchaseRequest(15000));
    }
}


// Define the base interface for data converters
interface DataConverter {
    void setNextConverter(DataConverter nextConverter);
    String convert(String data);
}

// Concrete implementation of DataConverter for JSON to XML conversion
class JsonToXmlConverter implements DataConverter {
    private DataConverter nextConverter;

    @Override
    public void setNextConverter(DataConverter nextConverter) {
        this.nextConverter = nextConverter;
    }

    @Override
    public String convert(String data) {
        // Perform JSON to XML conversion
        return "<xml>" + data + "</xml>";
    }
}

// Concrete implementation of DataConverter for XML to CSV conversion
class XmlToCsvConverter implements DataConverter {
    private DataConverter nextConverter;

    @Override
    public void setNextConverter(DataConverter nextConverter) {
        this.nextConverter = nextConverter;
    }

    @Override
    public String convert(String data) {
        // Perform XML to CSV conversion
        return data.replaceAll("<", ",").replaceAll(">", "");
    }
}

// Concrete implementation of DataConverter for CSV to JSON conversion
class CsvToJsonConverter implements DataConverter {
    private DataConverter nextConverter;

    @Override
    public void setNextConverter(DataConverter nextConverter) {
        this.nextConverter = nextConverter;
    }

    @Override
    public String convert(String data) {
        // Perform CSV to JSON conversion
        return "{\"json\": \"" + data + "\"}";
    }
}

public class DataConversionPipeline {
    public static void main(String[] args) {
        // Create instances of converters
        DataConverter jsonToXmlConverter = new JsonToXmlConverter();
        DataConverter xmlToCsvConverter = new XmlToCsvConverter();
        DataConverter csvToJsonConverter = new CsvToJsonConverter();

        // Set up the pipeline
        jsonToXmlConverter.setNextConverter(xmlToCsvConverter);
        xmlToCsvConverter.setNextConverter(csvToJsonConverter);

        // Input data in JSON format
        String jsonData = "{ \"key\": \"value\" }";

        // Process data through the pipeline
        String result = jsonToXmlConverter.convert(jsonData);

        // Output the result
        System.out.println("Result: " + result);
    }
}












import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// Interface representing the subject
interface Subject {
    void doSomething();
}

// Concrete implementation of the subject
class RealSubject implements Subject {
    @Override
    public void doSomething() {
        System.out.println("RealSubject is doing something...");
    }
}

// Invocation handler for the proxy
class DynamicProxy implements InvocationHandler {
    private final Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before invoking " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("After invoking " + method.getName());
        return result;
    }
}

public class DynamicProxyExample {
    public static void main(String[] args) {
        // Create the real subject instance
        RealSubject realSubject = new RealSubject();

        // Create the dynamic proxy
        Subject proxySubject = (Subject) Proxy.newProxyInstance(
                Subject.class.getClassLoader(),
                new Class[]{Subject.class},
                new DynamicProxy(realSubject)
        );

        // Call the method through the proxy
        proxySubject.doSomething();
    }
}










// Visitor interface
interface Visitor {
    void visit(Book book);
    void visit(Fruit fruit);
}

// Concrete Visitor
class ShoppingCartVisitor implements Visitor {
    @Override
    public void visit(Book book) {
        System.out.println("Book: " + book.getTitle() + ", Price: " + book.getPrice());
    }

    @Override
    public void visit(Fruit fruit) {
        System.out.println("Fruit: " + fruit.getName() + ", Weight: " + fruit.getWeight() + ", Price: " + fruit.getPrice());
    }
}

// Element interface
interface ItemElement {
    void accept(Visitor visitor);
}

// Concrete Element - Book
class Book implements ItemElement {
    private String title;
    private double price;

    public Book(String title, double price) {
        this.title = title;
        this.price = price;
    }

    public String getTitle() {
        return title;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

// Concrete Element - Fruit
class Fruit implements ItemElement {
    private String name;
    private double weight;
    private double price;

    public Fruit(String name, double weight, double price) {
        this.name = name;
        this.weight = weight;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getWeight() {
        return weight;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

// Client
public class VisitorPatternDemo {
    public static void main(String[] args) {
        ItemElement[] items = new ItemElement[]{
            new Book("Design Patterns", 30.00),
            new Fruit("Apple", 2.0, 3.00)
        };

        Visitor visitor = new ShoppingCartVisitor();
        for (ItemElement item : items) {
            item.accept(visitor);
        }
    }
}













import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }

    public static void main(String[] args) {
        LRUCache<Integer, String> cache = new LRUCache<>(3);

        cache.put(1, "one");
        cache.put(2, "two");
        cache.put(3, "three");
        System.out.println("Cache: " + cache);

        // Access key 1
        cache.get(1);
        System.out.println("Cache after accessing key 1: " + cache);

        // Add another element, which should evict the least recently used (key 2)
        cache.put(4, "four");
        System.out.println("Cache after adding key 4: " + cache);
    }
}


import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;

public class LFUCache<K, V> {
    private final int capacity;
    private int minFrequency;
    private final Map<K, V> cache;
    private final Map<K, Integer> keyFrequency;
    private final Map<Integer, LinkedHashSet<K>> frequencyList;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.minFrequency = 0;
        this.cache = new HashMap<>();
        this.keyFrequency = new HashMap<>();
        this.frequencyList = new HashMap<>();
    }

    public V get(K key) {
        if (!cache.containsKey(key)) {
            return null;
        }
        int frequency = keyFrequency.get(key);
        keyFrequency.put(key, frequency + 1);
        frequencyList.get(frequency).remove(key);

        if (frequencyList.get(frequency).isEmpty()) {
            frequencyList.remove(frequency);
            if (minFrequency == frequency) {
                minFrequency++;
            }
        }

        frequencyList.computeIfAbsent(frequency + 1, k -> new LinkedHashSet<>()).add(key);
        return cache.get(key);
    }

    public void put(K key, V value) {
        if (capacity <= 0) {
            return;
        }

        if (cache.containsKey(key)) {
            cache.put(key, value);
            get(key);  // Update the frequency of the key
            return;
        }

        if (cache.size() >= capacity) {
            K evict = frequencyList.get(minFrequency).iterator().next();
            frequencyList.get(minFrequency).remove(evict);
            if (frequencyList.get(minFrequency).isEmpty()) {
                frequencyList.remove(minFrequency);
            }
            cache.remove(evict);
            keyFrequency.remove(evict);
        }

        cache.put(key, value);
        keyFrequency.put(key, 1);
        minFrequency = 1;
        frequencyList.computeIfAbsent(1, k -> new LinkedHashSet<>()).add(key);
    }

    public static void main(String[] args) {
        LFUCache<Integer, String> lfuCache = new LFUCache<>(3);

        lfuCache.put(1, "one");
        lfuCache.put(2, "two");
        lfuCache.put(3, "three");
        System.out.println("Cache after adding 1, 2, 3: " + lfuCache.cache);

        lfuCache.get(1);
        lfuCache.get(1);
        lfuCache.get(2);
        System.out.println("Cache after accessing 1 twice and 2 once: " + lfuCache.cache);

        lfuCache.put(4, "four");
        System.out.println("Cache after adding 4 (should evict key 3): " + lfuCache.cache);

        lfuCache.get(4);
        lfuCache.get(4);
        lfuCache.put(5, "five");
        System.out.println("Cache after adding 5 (should evict key 2): " + lfuCache.cache);
    }
}







