class SharedData{
  int value = 0;
  int MAX = 100;
  boolean flag = true;
  
  public synchronized void incrementFirst() {
         while(value < MAX){
		   while (!flag) {
                try {
                    wait();
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
		   
		   System.out.println(Thread.currentThread().getName() + " => " + value);
		   value++;
		   flag = false;
		   notify();
		 }
  }

  public synchronized void incrementSecond() {
	  while(value < MAX){
	    while (flag) {
                try {
                    wait();
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
		System.out.println(Thread.currentThread().getName() + " => " + value);
		value++;
		flag = true;
		notify();
	  }
  }
}

class First implements Runnable{
   public SharedData sharedData;
    public First(SharedData sharedData){
	  this.sharedData = sharedData;
	}
    public void run(){
	  this.sharedData.incrementFirst();
	}
}

class Second implements Runnable{
public SharedData sharedData;
  public Second(SharedData sharedData){
     this.sharedData = sharedData;
  }
   public void run(){
     this.sharedData.incrementSecond();
   }
}
public class Main {
	public static void main(String[] args) throws InterruptedException {
	    SharedData sharedData = new SharedData();
        Thread t1 = new Thread(new First(sharedData), "t1");
        Thread t2 = new Thread(new Second(sharedData), "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("all tasks completed.");
	}
}



ReentrantLock provides a method called lockInterruptibly(), which can be used to interrupt thread when it is waiting for lock. 
Similarly tryLock() with timeout can be used to timeout if lock is not available in certain time period.
Fairness property provides lock to longest waiting thread, in case of contention.
ReentrantLock also provides convenient method to get List of all threads waiting for lock. 
We can create different conditions for Lock and different thread can await() for different conditions.
synchronization blocks or methods can cover only one method 
whereas we can acquire the lock in one method and release it in another method with Lock API.

public class ReentrantLockDemo {
	public static void main(String[] args) {
		ReentrantLock reentrantLock = new ReentrantLock();
		ExecutorService pool = Executors.newFixedThreadPool(2);
		Runnable runnable1 = new Worker(reentrantLock, "Job One");
		Runnable runnable2 = new Worker(reentrantLock, "Job Two");
		pool.execute(runnable1);
		pool.execute(runnable2);
		pool.shutdown();
	}
}

class Worker implements Runnable {
	String name;
	ReentrantLock reentrantLock;

	public Worker(ReentrantLock reentrantLock, String name) {
		this.reentrantLock = reentrantLock;
		this.name = name;
	}

	@Override
	public void run() {
		System.out.println("Name of Thread:"+this.name);
		// Getting Outer Lock
		boolean gotLock = reentrantLock.tryLock();
		if (gotLock) {
			try {
				// do something...				
				// Getting Inner Lock
				reentrantLock.lock();
				try {					
					// do something else...
					System.out.println("Lock Hold Count:" 
					+ reentrantLock.getHoldCount());
				} finally {
					// Inner lock release
					reentrantLock.unlock();
				}
			} finally {
				// Outer lock release
				reentrantLock.unlock();
				System.out.println("Lock Hold Count After Run:" 
						+ reentrantLock.getHoldCount());
			}
		}
	}
}





If only one person is allowed to come inside the meditation room it will be called MUTEX.

Assume N numbers of people are allowed to come inside the meditation room. 
If anybody leaves the room then another person can be allowed to come inside and relax. This will be called SEMAPHORE.

If no one is allowed to enter the meditation room until x number of people arrives, 
where each person has free will to leave the meditation room. This will be called COUNTDOWNLATCH.

Letâ€™s say we have an instructor, who will not start the meditation class until all the persons enter and grab the seat. 
Once the meditation class is finished the same barrier will be applied for the next class. This is called CYCLICBARRIER.


 It implies that CountDownLatch is good for one-time events like application start-up time
 and CyclicBarrier can be used in case of the recurrent event.
 
 We can say CyclicBarrier maintains a count of threads whereas CountDownLatch maintains a count of tasks.
 
 
 
 
 
 
 
 Resource Pools: Managing a fixed number of resources, such as database connections or thread pools.
Rate Limiting: Limiting the rate of requests or tasks being processed concurrently.
Critical Sections: Protecting critical sections of code that should only be accessed by a specific number of threads simultaneously.
Coordination: Synchronizing multiple threads to perform certain tasks with controlled concurrency.
 public class SemaphoreExample {

    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);  // Three permits

        for (int i = 0; i < 10; i++) {
            new Thread(new Worker(semaphore)).start();
        }
    }
}

class Worker implements Runnable {
    private final Semaphore semaphore;

    Worker(Semaphore semaphore) {
        this.semaphore = semaphore;
    }

    @Override
    public void run() {
        try {
            semaphore.acquire();  // Acquire a permit
            System.out.println(Thread.currentThread().getName() + " is working.");
			// Simulate request processing
            Thread.sleep((long) (Math.random() * 1000));
            System.out.println(Thread.currentThread().getName() + " has finished.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();  // Release the permit
        }
    }
}
 
 
 
 
 public class CyclicBarrierExample {

    public static void main(String[] args) {
        int numberOfThreads = 3;

        // Initialize CyclicBarrier with 3 parties (threads)
        CyclicBarrier barrier = new CyclicBarrier(numberOfThreads, () -> System.out.println("All parties have arrived at the barrier. Barrier broken!"));

        // Create and start 3 threads
        for (int i = 0; i < numberOfThreads; i++) {
            new Thread(new Task(barrier)).start();
        }
    }
}

class Task implements Runnable {
    private final CyclicBarrier barrier;

    public Task(CyclicBarrier barrier) {
        this.barrier = barrier;
    }

    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName() + " is performing its task.");
            Thread.sleep(1000);  // Simulate some work

            System.out.println(Thread.currentThread().getName() + " has finished its task and is waiting at the barrier.");
            barrier.await();  // Wait at the barrier

            System.out.println(Thread.currentThread().getName() + " has crossed the barrier.");
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}
 
 
 public class CountDownLatchTimeoutExample {

    public static void main(String[] args) {
        CountDownLatch latch = new CountDownLatch(2);

        new Thread(new DataWorker(latch, 1)).start();
        new Thread(new DataWorker(latch, 1)).start();

        try {
            if (latch.await(1, TimeUnit.SECONDS)) {
                System.out.println("All workers finished within the timeout.");
            } else {
                System.out.println("Timeout reached before all workers finished.");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class DataWorker implements Runnable {
    private final CountDownLatch latch;
	private final int workerId;

    DataWorker(CountDownLatch latch) {
        this.latch = latch;this.workerId = workerId;
    }

    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName() + " is working.");
            Thread.sleep((long) (Math.random() * 2000));  // Simulate work
            System.out.println(Thread.currentThread().getName() + " has finished.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            latch.countDown();  // Decrement the count
        }
    }
}
 
 
 
 
 
 
 
 
public class CountDownLatchDemo {
    public static void main(String args[]) {
       final CountDownLatch latch = new CountDownLatch(4);
       Thread service1 = new Thread(new Service("service1", 1000, latch));
       Thread service2 = new Thread(new Service("service2", 1000, latch));
       Thread service3 = new Thread(new Service("service3", 1000, latch));
       Thread service4 = new Thread(new Service("service4", 1000, latch));
       service1.start();
       service2.start();
       service3.start();
       service4.start();
       try{
            latch.await();  //main thread is waiting on CountDownLatch to finish
            System.out.println("All services are up..Application is starting now!!");
       }catch(InterruptedException ie){
           ie.printStackTrace();
       }     
    } 
}
public class Service implements Runnable{
    private final String serviceName;
    private final int timeToStart;
    private final CountDownLatch latch;
 
    public Service(String serviceName, int timeToStart, CountDownLatch latch){
        this.serviceName = serviceName;
        this.timeToStart = timeToStart;
        this.latch = latch;
    }
 
    @Override
    public void run() {
        try {
            Thread.sleep(timeToStart);
        } catch (InterruptedException ex) {
        }
        System.out.println( serviceName + " is now UP");
        latch.countDown(); //reduce count of CountDownLatch by 1
    } 
}

1). If CyclicBarrier is initialized with 3 parties, 3 threads need to call the await method to break the barrier.
2). The thread will block on await() until all parties reach the barrier, another thread interrupt or await timed out.
3). If another thread interrupts the thread which is waiting on barrier it will throw BrokernBarrierException as shown below:
java.util.concurrent.BrokenBarrierException
at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:172)
at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:327)
4). CyclicBarrier.reset() puts Barrier on its initial state, another thread which is waiting or not yet reached the barrier will terminate with java.util.concurrent.BrokenBarrierException.



public class CyclicBarrierDemo {
    public static void main(String args[]) throws InterruptedException, BrokenBarrierException {
        CyclicBarrier barrier = new CyclicBarrier(4);
        Party first = new Party(1000, barrier, "Party1");
        Party second = new Party(2000, barrier, "Party2");
        Party third = new Party(3000, barrier, "Party3");
        Party fourth = new Party(4000, barrier, "Party4");

        first.start();
        second.start();
        third.start();
        fourth.start();
        System.out.println(Thread.currentThread().getName() + " has finished");
    }
}
public class Party extends Thread {
    private int duration;
    private CyclicBarrier barrier;

    public Party(int duration, CyclicBarrier barrier, String name) {
        super(name);
        this.duration = duration;
        this.barrier = barrier;
    }
  83008511517
  83008511517
    @Override
    public void run() {
        try {
            Thread.sleep(duration);
            System.out.println(Thread.currentThread().getName() + " is calling await()");
            barrier.await();
            System.out.println(Thread.currentThread().getName() + " has started running again");
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}



If number%3 == 1 then T1 will print the number and increment it else will go in the wait state.
If number%3 == 2 then T2 will print the number and increment it else will go in the wait state.
If number%3 == 0 then T3 will print the number and increment it else will go in the wait state.



public class Main {
	public static void main(String[] args) {
	    StringBuilder current = new StringBuilder();
	    String value = "adsd,,fdf..sf,";
	    char[] array = value.toCharArray();
	    int counnter = 0;
	    for(char ch: array){
	        if(ch == ',' || ch == '.'){
	            if(current.length()> 0){
	                counnter++;
	                current.setLength(0);
	            }
	            
	        }else {
	            current.append(ch);
	        }
	    }
	    if(current.length() > 0){
	       counnter++;
	    }
		System.out.println(counnter);
	}
}
