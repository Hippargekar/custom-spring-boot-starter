
Common Applications of Stack:
Expression Evaluation and Conversion:
Infix to Postfix/Prefix conversions and evaluations often use stacks.
Example: Convert an infix expression like A + B * C to postfix A B C * +.
2. Backtracking:

When you need to explore all possibilities (like in maze solving, path finding, or backtracking problems like N-Queens), stacks are useful.
3. Function Call Management:

The system call stack manages the function calls during the execution of programs, particularly recursive function calls.
4. Undo/Redo Operations:

Applications that need to maintain history (like text editors or drawing applications) often use two stacks for undo and redo operations.
5. Parsing:

Stacks are used for parsing expressions and validating balanced parentheses in expressions.




Queue<Integer> queue = new LinkedList<>();
Queue<Integer> queue = new PriorityQueue<>();
 Iterator<String> iterator = queue.iterator();
 while (iterator.hasNext()) {
	 String element = iterator.next();
	 System.out.println(element);
 }
 
// Process print jobs in the order they arrive
while (!queue.isEmpty()) {
    String currentJob = queue.remove();
    System.out.println("Printing: " + currentJob);
} 
Managing Printer Jobs: Ensuring documents are printed in the order they were sent.
Keyboard Buffer: Storing keystrokes so that they’re processed in the order they were entered.
Breadth-First Search (BFS): In algorithms, queues are used to traverse graphs or trees level by level.

 
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue; 
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(2);  

ArrayDeque: A Versatile Queue and Stack Hybrid
 Deque<String> deque = new ArrayDeque<>();
 Not thread-safe


class Node {
    int data;
    Node prev;  // Reference to the previous node
    Node next;  // Reference to the next node
    
    // Constructor
    public Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

Why Root Cause Analysis (RCA) is Essential in Software Development?
Reproduce the Issue: Try to recreate the problem in a controlled environment.
Analyze Logs & Stack Traces: Identify patterns and anomalies leading up to the failure.
Ask “Why” Five Times: A structured method to trace the issue back to its origin.
Look for Systemic Issues: Is this failure a symptom of a deeper architectural flaw?
Apply a Permanent Fix: Once the root cause is found, fix it at the source rather than applying superficial workarounds.


HashMap: Ideal for implementing caches, lookup tables, or dictionaries.
TreeMap: sorted dictionaries or range queries/operations

HashSet: Ideal for membership tests, eliminating duplicates, or implementing sets.
TreeSet: ideal for applications requiring ordered traversal or range operations.

PriorityQueue: It's perfect for scenarios where processing order is determined by element priority rather than insertion order.

ConcurrentHashMap provides a high-performance, thread-safe alternative to HashMap.
where multiple threads access and modify the map concurrently, such as caching systems, real-time data processing, or shared configurations.



class CircularQueue {
    private int[] data;
    private int front, rear, size;

    public CircularQueue(int capacity) {
        data = new int[capacity];
        front = rear = size = 0;
    }
    public boolean enqueue(int value) {
        if (size == data.length) return false; // Queue is full
        data[rear] = value;
        rear = (rear + 1) % data.length;
        size++;
        return true;
    }
    public int dequeue() {
        if (size == 0) throw new NoSuchElementException("Queue is empty");
        int result = data[front];
        front = (front + 1) % data.length;
        size--;
        return result;
    }
    public int peek() {
        if (size == 0) throw new NoSuchElementException("Queue is empty");
        return data[front];
    }
    public boolean isEmpty() {
        return size == 0;
    }
}












Write a simple Spring Boot REST API that returns "Hello, World!"

@RestController
@RequestMapping("/api")
class  HelloController {

	@GetMappping("/hello")
	public ResponseEntity<String> helloWorld(){
	   return ResponseEntity.ok("Hello, World!");
	}

}

"Count the repeatable characters in the following string: “java is a programming language";
Proficiency in Java unit testing frameworks like JUnit and Mockito.
Contribute to all stages of software development lifecycle
Experience in programming with Messaging (Kafka, RabbitMQ), Caching (Ehcache, Radis), and Elastic search.

import java.util.stream.*;
public class Main {
    public static void main(String[] args) {
        // Input string
        String text = ""java is a programming language"";
         str.chars.stream().mapToObj( d -> (char) c)
		 .collect(Collectors.GroupBy(Collectors.identity, Collectors.counting))
		 .foreach(entry->  {
		    if(entry.getValue()> 1){
			  System.out.pritln(  entry.getKey()   +"  occurece  "+entry.getValue())
			} 
		 })       
    }
}



import java.util.concurrent.*;

public class Service {

    private final ExecutorService executorService;

    public Service() {
        executorService = Executors.newSingleThreadExecutor();
    }

    public void testExecutorServiceInterrputCallable() {
            setTimeout(executorService.submit(() -> someBlockingTask()), 1);
            System.out.println("Continue main thread!");
            shutdownExecutorService();
    }

    private void setTimeout(Future<?> futureTask, int timeoutInSeconds) {
        try {
            futureTask.get(timeoutInSeconds, TimeUnit.SECONDS); // 1
        } catch (InterruptedException | ExecutionException ex) {
            ex.printStackTrace();
        } catch (TimeoutException timeoutException) {
            futureTask.cancel(true); // 2
        }
    }

    private void someBlockingTask() {
        for(long i=0; i<=10000000;i++) {
            System.out.println(i);
            if(Thread.currentThread().isInterrupted()) { // 3
                System.out.println("The callable has been interrupted!");
                return;
            }
        }
    }

    private void shutdownExecutorService() {
        executorService.shutdown();
        if(!executorService.isShutdown()) {
            executorService.shutdownNow();
        }
    }
}


import java.util.concurrent.*;

public class Service {

    private final ExecutorService executorService;

    public Service() {
        executorService = Executors.newFixedThreadPool(1);
    }

    public void testExecutorServiceInterrputCallable() {
        setTimeout(executorService.submit(() -> someBlockingTask()), 1);
        System.out.println("Continue main thread!");
        shutdownExecutorService();
    }

    private void setTimeout(Future<?> futureTask, int timeoutInSeconds) {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(timeoutInSeconds, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException ie) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    private void someBlockingTask() {
        for (long i = 0; i <= 10000000; i++) {
            System.out.println(i);
            if (Thread.currentThread().isInterrupted()) { // 3
                System.out.println("The callable has been interrupted!");
                return;
            }
        }
    }

    private void shutdownExecutorService() {
        executorService.shutdown();
        if (!executorService.isShutdown()) {
            executorService.shutdownNow();
        }
    }
}





server.use-forward-headers=true
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private static final String HAS_SONG_SERVICE_IPS = "hasIpAddress('90.100.1.0/22') or hasIpAddress('140.134.165.0/20')";

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().authorizeRequests().antMatchers(HttpMethod.POST,"/v1/**").access(HAS_SONG_SERVICE_IPS);
    }
}

OR ....................
@Component
public class RequestTelegramOriginatedFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {
        if (matches(request, "149.154.160.0/20") || matches(request, "91.108.4.0/22")) {
            filterChain.doFilter(request, response);
        }
    }

    private boolean matches(HttpServletRequest request, String subnet) {
        IpAddressMatcher ipAddressMatcher = new IpAddressMatcher(subnet);
        return ipAddressMatcher.matches(request);
    }
}





public class Application {

    private void processLargeDataSet() {
        List<String> largeDataset = getLargeDataset();
        ForkJoinPool customThreadPool = new ForkJoinPool(5);
        customThreadPool.submit(() -> largeDataset.parallelStream().forEach(System.out::println));
        customThreadPool.shutdownNow();
    }

    private List<String> getLargeDataset() {
        List<String> largeDataset = new ArrayList<>();
        IntStream.range(0, Integer.MAX_VALUE).forEach(i -> {
            largeDataset.add(UUID.randomUUID().toString());
        });
        return largeDataset;
    }
}

@ExtendWith(MockitoExtension.class)
public class UserRepositoryTest {

    @InjectMocks
    private UserRepository userRepository;

    @Test
    void shouldReturnUserByUsername() throws UserNotFoundException {
        var expected = new User("test", "first name", "last name");

        var result = userRepository.findByUsername("test");

        assertThat(result).isEqualTo(expected);
    }

    @Test
    void shouldNotThrowExceptionWhenRetrievingUser() {
        assertDoesNotThrow(() -> userRepository.findBy("test"));
        assertThatCode(() -> userRepository.findBy("test")).doesNotThrowAnyException();
    }

    @Test
    void shouldThrowUserNotFoundException() {
        assertThatThrownBy(() -> userRepository.findByUsername("nonExistenceUsername"))
            .isInstanceOf(UserNotFoundException.class)
            .hasMessage("Cannot find username: nonExistenceUsername");
    }

    @Test
    void shouldVerifyUserNotFoundExceptionIsThrown() {
        assertThrows(UserNotFoundException.class, () -> userRepository.findByUsername("nonExistenceUsername"));
    }
}



@ExtendWith(MockitoExtension.class)
public class StudentServiceJUnit5WithAnnotationTest {

    @InjectMocks
    private StudentService studentService;

    @Mock
    private CourseService courseService;

    @Test
    public void testCalculatingCGPA() {
        long studentId = 1L
        when(courseService.getAllCoursesByStudentId(anyLong())).thenReturn(stubCourses());
        
        long cGPA = studentService.getCGPA(studentId);

        verify(courseService, times(1)).getAllCoursesByStudentId(anyLong());
        assertEquals("3.4", cGPA);
    }
}



<dependency>

    <groupId>org.mockito</groupId>

    <artifactId>mockito-core</artifactId>

    <version>5.x</version>

</dependency>

<dependency>

    <groupId>org.junit.jupiter</groupId>

    <artifactId>junit-jupiter</artifactId>

    <version>5.x</version>

</dependency>

when(mockObject.someMethod()).thenThrow(new RuntimeException("Error"));

Use doNothing() or doThrow() for void methods.
.................................................................................
doNothing().when(mockObject).someVoidMethod();
doThrow(new RuntimeException()).when(mockObject).someVoidMethod();
https://tech-talk.the-experts.nl/mastering-void-method-testing-with-mockito-in-spring-boot-applications-4f19e0a6259d

junit-s-engine ✅ (JUnit 5)
junit-vintage-engine ❌ (JUnit 4 runner, optional)
mvn dependency:tree | grep vintage


        <!-- ✅ Spring Boot Test Starter (JUnit 5, Mockito included) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <!-- ❌ Exclude JUnit 4 Vintage Engine (only JUnit 5 will be used) -->
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!-- ✅ Optional: Add this if you want to use Mockito directly -->
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>
		
		
@Test
void shouldThrowExceptionForInvalidUser() {
    UserRepository mockRepository = mock(UserRepository.class);
    UserService userService = new UserService(mockRepository);

    // Define a custom answer that throws an exception when username is "invalidUser"
    when(mockRepository.findByUsername(anyString())).thenAnswer(invocation -> {
        String username = invocation.getArgument(0); 
        if (username.equals("invalidUser")) {
            throw new IllegalArgumentException("Invalid username");
        }
        return Optional.empty(); // Return empty Optional for other usernames
    });

    // Expect an exception to be thrown when trying to find an invalid user
    assertThrows(IllegalArgumentException.class, () -> userService.findUserByUsername("invalidUser"));
}







api.endpoint=https://dummyjson.com/test
@Service
public class WeatherApi {

  private static final Logger logger = LoggerFactory.getLogger(WeatherApi.class);

  @Value("${api.endpoint}")
  private String apiEndpoint;

  public String getApiEndpoint() {
    return apiEndpoint;
  }

}
@ExtendWith(MockitoExtension.class)
class WeatherApiTest {

  @InjectMocks
  private WeatherApi weatherApi;

  @BeforeEach
  void initialize() {
    ReflectionTestUtils.setField(weatherApi, "apiEndpoint", "https://weather-api.com");
  }

  @Test
  void testGetWeatherApiEndpointAddress() {
    String result = weatherApi.getApiEndpoint();

    assertEquals("https://weather-api.com", result);
  }
}




















































