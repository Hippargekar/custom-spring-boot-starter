PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
A regular PriorityQueue is not thread-safe, meaning concurrent access by multiple threads can result in unpredictable behavior or corrupted data.
To handle thread safety, you can use PriorityBlockingQueue, which is a thread-safe alternative provided in the java.util.concurrent package. It supports concurrent access while maintaining priority order.

import java.util.*;
class PriorityQueue_Heap {
    public static void main( String args[] ) {

        //MinHeap
        PriorityQueue<Integer> min = new PriorityQueue<>();
        // offer() and add() are used to add elements
        min.add(51);
        min.offer(6);
        min.add(72);
        min.add(1);
        min.add(2);
        min.offer(3);
        min.offer(4);
        min.add(11);
        min.add(19);
        System.out.println("Elements in this Min queue are: ");
        System.out.println(min);

        //remove top 2 elements /min i.e 1 & 2
        System.out.println("remove top 2 elements/Min: ");
        min.remove();
        min.remove();
        System.out.println(min);

        // printing size of the queue
        System.out.println("Size of this min queue is: " + min.size());

        // removing values based on priority and printing them
        System.out.println("Min Priority Queue:");
        while (!min.isEmpty()) {
            System.out.println(min.remove());
        }

        System.out.println();
        System.out.println();
        System.out.println();

        //MaxHeap
        //Passing comparator as lambda expression for reverse order of insertion i.e descending order
        PriorityQueue<Integer> max = new PriorityQueue<>((x, y) -> Integer.compare(y, x));
        // offer() and add() are used to add elements
        max.add(51);
        max.offer(6);
        max.add(72);
        max.add(1);
        max.add(2);
        max.offer(3);
        max.offer(4);
        max.add(11);
        max.add(19);
        System.out.println("Elements in this Max queue are: ");
        System.out.println(max);

        //remove top 2 elements /min i.e 1 & 2
        System.out.println("remove top 2 elements/Max: ");
        max.remove();
        max.remove();
        System.out.println(max);

        // printing size of the queue
        System.out.println("Size of this Max queue is: " + max.size());

        // removing values based on priority and printing them
        System.out.println("Max Priority Queue:");
        while (!max.isEmpty()) {
            System.out.println(max.remove());
        }
    }
}





"America", "akash", "Mars", "anubhav", "nitish", "ashish", "alpha"
Output - AMERICA, AKASH, ANUBHAV, ASHISH, ALPHA
Explanation - Print all elements which start with A or a in Upper Case

List<String> uppsecase = list.stream()
.filter(data-> data.startwith("A") || data.startwith("a"))
.map(String::toUppercase())
.collect(Collectors.toList());


import java.util.*;
import java.util.stream.*;
public class Main
{
	public static void main(String[] args) {
		String value = "aabbzbccdeffcfzzzz";
		int [] arr = new int[256];// default valut value is zero.
		for(Character ch: value.toCharArray()){
		       arr[ch] = arr[ch] + 1;    
		}
		int max = arr[0];
		int idx = 0;
		for (int index = 0; index< arr.length; index ++){
		    if(arr[index] > max ){
		        max = arr[index];
		        idx = index;
		    }
		}
          System.out.println(max +" "+(char)idx);	    
	}
}

final class EmmutableClass{
   private final String name;
   
   public  EmmutableClass(String name){
      this.name= name;
   }

   public getName(){
    return name;
   }

}























Java Developer
Synoris
Design, develop, test, deploy, and maintain scalable microservices using Java and AWS.





Java Developer
Synoris


public interface Color {
    void applyColor();
}
public class RedColor implements Color{
    public void applyColor(){
        System.out.println("red.");
    }
}
public class GreenColor implements Color{
    public void applyColor(){
        System.out.println("green.");
    }
}
public abstract class Shape {
    protected Color color;
    
    protected Shape(Color c){
        this.color = c;
    }
    
    public abstract public void applyColor();
}
public class Triangle extends Shape {

    public Triangle(Color c) {
        super(c);
    }

    @Override
    public void applyColor() {
        System.out.print("Triangle filled with color ");
        color.applyColor();
    } 

}
public class Pentagon extends Shape {

    public Pentagon(Color c) {
        super(c);
    }

    @Override
    public void applyColor() {
        System.out.print("Pentagon filled with color ");
        color.applyColor();
    } 

}
public class BridgePatternTest {

    public static void main(String[] args) {
        Shape tri = new Triangle(new RedColor());
        tri.applyColor();
        
        Shape pent = new Pentagon(new GreenColor());
        pent.applyColor();
    }

}













public interface StockObserver {
    void update(String stockSymbol, double stockPrice);
}
public class Investor implements StockObserver {
    private String name;

    public Investor(String name) {
        this.name = name;
    }

    @Override
    public void update(String stockSymbol, double stockPrice) {
        System.out.println(name + " received an update for " + stockSymbol + ": $" + stockPrice);
    }
}
public interface StockMarket {
    void registerObserver(StockObserver observer);
    void removeObserver(StockObserver observer);
    void notifyObservers(String stockSymbol, double stockPrice);
}
import java.util.ArrayList;
import java.util.List;

public class StockMarketImpl implements StockMarket {
    private List<StockObserver> observers = new ArrayList<>();

    @Override
    public void registerObserver(StockObserver observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(StockObserver observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers(String stockSymbol, double stockPrice) {
        for (StockObserver observer : observers) {
            observer.update(stockSymbol, stockPrice);
        }
    }

    // Simulate stock price changes
    public void setStockPrice(String stockSymbol, double stockPrice) {
        notifyObservers(stockSymbol, stockPrice);
    }
}
public class Main {
    public static void main(String[] args) {
        StockMarket stockMarket = new StockMarketImpl();

        StockObserver investor1 = new Investor("Alice");
        StockObserver investor2 = new Investor("Bob");

        stockMarket.registerObserver(investor1);
        stockMarket.registerObserver(investor2);

        stockMarket.setStockPrice("INFY", 1250.0); // Both investors receive updates
        stockMarket.setStockPrice("TCS", 2500.0); // Both investors receive updates

        stockMarket.removeObserver(investor1);

        stockMarket.setStockPrice("WIPRO", 700.0); // Only investor2 receives the update
    }
}





















public record PaymentReqDto(double amount){}
public record PaymentResDto(String message){}
public interface PaymentGateway {
    PaymentResDto processPayment(PaymentReqDto reqDto);
}
public class PayPalAdapter implements PaymentGateway {
    private PayPal paymentGateway;

    public PayPalAdapter(PayPal paymentGateway) {
        this.paymentGateway = paymentGateway;
    }

    @Override
    PaymentResDto processPayment(PaymentReqDto reqDto) {
        // Convert our application's method to PayPal's method
        paymentGateway.makePayment(amount);
    }
}
public record PayPalReqDto(double amount){}
public record PayPalResDto(String message){}
public class PayPal {
    public PayPalResDto makePayment(PayPalReqDto reqDto) {
        // PayPal-specific payment processing logic
        new PayPalResDto("Paid $" + amount + " via PayPal.");
    }
}
public class StripeAdapter implements PaymentGateway {
    private Stripe paymentGateway;

    public StripeAdapter(Stripe paymentGateway) {
        this.paymentGateway = paymentGateway;
    }

    @Override
    PaymentResDto processPayment(PaymentReqDto reqDto) {
        // Convert our application's method to Stripe's method
        paymentGateway.chargePayment(amount);
    }
}
public record StripeReqDto(double amount){}
public record StripeResDto(String message){}
public class Stripe {
    public StripeResDto chargePayment(StripeReqDto reqDto) {
        // Stripe-specific payment processing logic
        new StripeResDto("Charged $" + amount + " using Stripe.");
    }
}
public class PaymentApp {
    public static void main(String[] args) {
        PaymentGateway paypalGateway = new PayPalAdapter(new PayPal());
        PaymentGateway stripeGateway = new StripeAdapter(new Stripe());

        double amount = 100.0;

        // Process payments using different payment gateways
        paypalGateway.processPayment(amount);
        stripeGateway.processPayment(amount);
    }
}
























