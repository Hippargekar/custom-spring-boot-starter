class OddEven {
    private int i;
    public int getI() {
        return i;
    }
    public int addI(){
        return i++;
    }
}
public class MyThreadTest {

  public static void main(String[] args) {

    OddEven oddEven = new OddEven();

    MyThread01 myThread03 = new MyThread01(oddEven);
    MyThread02 myThread04 = new MyThread02(oddEven);

    myThread01.setName("thread 1");
    myThread02.setName("thread 2");

    myThread02.start();
    myThread01.start();

  }
}

class MyThread02 implements Runnable{
    private OddEven i;
    public MyThread02(OddEven i) {
        this.i = i;
    }
 
    @Override
    public void run() {
        while(i.getI()<100){
            synchronized (i){
                if(i.getI()%2==0){
                    System.out.println (Thread.currentThread ().getName () +"output"+ i.addI());
                    i.notify();
                }  else {
                    try {
                        i.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
 
            }
 
        }
    }
}

class MyThread01 implements Runnable{
    private OddEven i;
    public MyThread01(OddEven i) {
        this.i = i;
    }
 
    @Override
    public void run() {
        while(i.getI()<100) {
            synchronized (i) {
                if(i.getI()%2==1) {
                    System.out.println (Thread.currentThread ().getName ()+"output"+ i.addI());
                    i.notify();
                } else {
                    try {
                        i.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
 
            }
        }
    }
}
	
import java.util.Arrays;

public class MinPlatforms {

    public static void main(String[] args) {

        // Arrival and departure times
        int[] arrival =    {900, 1000, 1100, 1300, 1015};
        int[] departure =  {1030, 1130, 1230, 1430, 1045};

        int platforms = findMinimumPlatforms(arrival, departure);
        System.out.println("üöâ Minimum number of platforms required: " + platforms);
    }

    public static int findMinimumPlatforms(int[] arrival, int[] departure) {
        int n = arrival.length;

        // Step 1: Sort both arrays
        Arrays.sort(arrival);
        Arrays.sort(departure);

        // Step 2: Use two pointers to track trains
        int platformNeeded = 1, maxPlatforms = 1;
        int i = 1, j = 0;

        while (i < n && j < n) {
            // If next train arrives before the last one departs, need extra platform
            if (arrival[i] <= departure[j]) {
                platformNeeded++;
                i++;
            } else {
                // One train has left, we can reuse a platform
                platformNeeded--;
                j++;
            }

            // Keep track of the maximum platforms needed at any time
            maxPlatforms = Math.max(maxPlatforms, platformNeeded);
        }

        return maxPlatforms;
    }
}


import java.util.Arrays;

public class MinPlatformsFrom2DArray {

    public static void main(String[] args) {
        int[][] trainTimes = {
            {900, 1030},    // Train 0
            {1000, 1130},   // Train 1
            {1100, 1230},   // Train 2
            {1300, 1430},   // Train 3
            {1015, 1045}    // Train 4
        };

        int minPlatforms = findMinimumPlatforms(trainTimes);
        System.out.println("üöâ Minimum number of platforms required: " + minPlatforms);
    }

    public static int findMinimumPlatforms(int[][] trainTimes) {
        int n = trainTimes.length;

        int[] arrivals = new int[n];
        int[] departures = new int[n];

        // Separate arrival and departure times from the 2D array
        for (int i = 0; i < n; i++) {
            arrivals[i] = trainTimes[i][0];
            departures[i] = trainTimes[i][1];
        }

        // Step 1: Sort both arrays
        Arrays.sort(arrivals);
        Arrays.sort(departures);

        // Step 2: Apply the two-pointer technique
        int platformNeeded = 1, maxPlatforms = 1;
        int i = 1, j = 0;

        while (i < n && j < n) {
            if (arrivals[i] <= departures[j]) {
                platformNeeded++;  // One more train on station
                i++;
            } else {
                platformNeeded--;  // A train has departed
                j++;
            }

            maxPlatforms = Math.max(maxPlatforms, platformNeeded);
        }

        return maxPlatforms;
    }
}



public static void main(String[] args) {
        List<String> merchantIdentifiers =  new ArrayList<>();
        int partitionSize = 10;
        for(int index =0 ; index <= 101; index++){
            merchantIdentifiers.add(index+"");
        }
        System.out.println(merchantIdentifiers);
        Collection<List<String>> partitionedList = IntStream.range(0, merchantIdentifiers.size())
                .boxed()
                .collect(Collectors.groupingBy(partition -> (partition / partitionSize), Collectors.mapping(elementIndex -> merchantIdentifiers.get(elementIndex), Collectors.toList())))
                .values();

        for (List<String> subList : partitionedList) {
            System.out.println(subList);
        }
}

    public static void map() {
        Map<String, Integer> map = new HashMap<>();
        map.put("One", 1);
        map.put("Two", 2);

        Iterator<Map.Entry<String, Integer>> itr = map.entrySet().iterator(); // create an iterator for the map entries
        while (itr.hasNext()) {
            Map.Entry<String, Integer> entry = itr.next(); // get the next entry
           // System.out.println(entry.getKey() + " = " + entry.getValue()); // print the entry
        }
	}	

    public void palindromeString(){
        String str1 = "anantnana";
        boolean isPalindrome = IntStream.range(0, str1.length() / 2)
                .noneMatch(i -> str1.charAt(i) != str1.charAt(str1.length() - i - 1));

        System.out.println("Is " + str1 + " Palindrome? -> " + isPalindrome);
    }
    public static void firstNonRepeatingCharacterInString(){
        String str = "abacdbef";
        Optional<Character> firstNonRepeatingChar =  str.chars()
                .mapToObj(cha-> (char) cha)
                .collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue() == 1)
                .map(Map.Entry::getKey)
                //.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
                .findFirst();
        firstNonRepeatingChar.ifPresent(System.out::println);
    }

    public static Map.Entry<Integer, List<String>> getNthHighestSalary(int n, Map<String,Integer> map){
        Map.Entry<Integer, List<String>> resultSalaryList = map.entrySet().stream()
                .collect(Collectors.groupingBy(Map.Entry::getValue,
                        Collectors.mapping(Map.Entry::getKey, Collectors.toList())
                ))
                .entrySet()
                .stream()
                .sorted(Collections.reverseOrder(Map.Entry.comparingByKey()))
                .collect(Collectors.toList())
                .get(n-1); //we can pass n=2 for second highest salary
        return resultSalaryList;
    }

        TreeMap<String, Integer> map =  Stream.of("cat", "fish", "cat", "cat")
                        .collect(Collectors.toMap(Function.identity(),
                                String::length,
                                (oldValue, nextValue) -> oldValue + 3,
                                TreeMap::new));
								
    public static void testReduce(){
        String st = Stream.of("A", "B", "C", "D", "E").parallel().reduce(
                "", // Identity
                (s11, s22) -> s11 + s22
        );
        System.out.println(st);

        int second = "079".chars()
                .map(ch -> ch - '0')
                .reduce(0, (sum, digit) -> sum * 10 + digit);
        System.out.println(second);
    }

	public static boolean backWordForWordSame(String str) {
		int strEnd = str.length()/2;
		int forWord = 0;
		int backWord = str.length() -1;
		while(forWord < strEnd){
			if(str.charAt(forWord) != str.charAt(backWord)){
				return false;
			}
			forWord++;backWord--;
		}
		return true;
	}

public static boolean areAnagrams(String str1, String str2) {
		// If lengths are different, they cannot be anagrams
		if (str1.length() != str2.length()) {
			return false;
		}

		// Use a map to count occurrences of each character in str1
		Map<Character, Integer> freqMap = new HashMap<>();

		// Count characters in str1
		for (char c : str1.toCharArray()) {
			freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
		}

		// Check characters in str2 against the map
		for (char c : str2.toCharArray()) {
			if (!freqMap.containsKey(c)) {
				// Character c is not present in str1
				return false;
			}

			// Decrease the count of character c
			freqMap.put(c, freqMap.get(c) - 1);

			// Remove the character from map if its count becomes zero
			if (freqMap.get(c) == 0) {
				freqMap.remove(c);
			}
		}

		// If all characters in str2 are accounted for, and the map is empty, they are anagrams
		return freqMap.isEmpty();
	}

//	String authorities = authentication.getAuthorities().stream()
//			.map(GrantedAuthority::getAuthority)
//			.collect(Collectors.joining(","));
//.claim(AUTHORITIES_KEY, authorities)

//	Collection<? extends GrantedAuthority> authorities =
//			Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(","))
//					.map(SimpleGrantedAuthority::new)
//					.collect(Collectors.toList());

EmployeeList.getEmployeeList().stream()
                .sorted(Comparator.comparingLong(Employee::getId).reversed()) // sorting is based on tagId 55,44,33,22,11
                .collect(Collectors.toMap(Employee::getName, Employee::getId,
                                (oldValue, newValue) -> oldValue,
                        TreeMap::new));	
List<Long> ids = bulkMdFileRecords.parallelStream().map(BulkMdFileUploadRecords::getId).collect(Collectors.toList());
Collection<List<Long>> partitionedList = IntStream.range(0, ids.size())
.boxed()
.collect(Collectors.groupingBy(partition -> (partition / partitionSize), Collectors.mapping(elementIndex -> ids.get(elementIndex), Collectors.toList())))
.values();



import java.util.stream.*;
public class Main
{
	public static void main(String[] args) {//length
	    String value = "abcdb";
	    
	    char[] chi = value.toCharArray();
	    System.out.println(chi);
	    for(char c :chi){
	        System.out.println(c);
	    }
	    
	    for(int index = 0; index < value.length(); index++){
	        char ch = value.charAt(index);
	        //System.out.println(ch +" "+value.indexOf(ch) +" "+value.lastIndexOf(ch));
	    }
	    
	    Stream<Character> chars = value.chars().mapToObj(d-> (char)d);
	    
	}
}

int threadsNumber = Runtime.getRuntime().availableProcessors();
executorService.submit(new Callable<>() {
    @Override
    public Integer call() {
        return new Random().nextInt();
    }
});
Future<Integer> future = executorService.submit(() -> new Random().nextInt());
future.get(1, TimeUnit.SECONDS);
future.cancel(true);
future.isCancelled();
future.isDone();

ExecutorService service = Executors.newFixedThreadPool(500);
for (int i = 0; i < 500; i++) {
    service.execute(() -> System.out.println("Doing some work"));
}


public static void main(String[] args) {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future<Integer> future = executor.submit(() -> {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return new Random().nextInt();
    });

    try {
        System.out.println("Result: " + future.get(1, TimeUnit.SECONDS));
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    } catch (TimeoutException e) {
        System.out.println("Couldn't complete the task before timeout");
    }

    executor.shutdown();
}










import java.util.concurrent.ExecutorService; 
import java.util.concurrent.Executors; 

class ThreadPoolExample { 
  public static void main(String[] args) { 
    // create a fixed size thread pool with 5 threads 
    ExecutorService service = Executors.newFixedThreadPool(5); 
    
    // submit tasks to be executed by the pool 
    for (int i = 0; i < 10; i++) { 
      service.submit(new Task(i)); 
    } 
    
    // shutdown the pool 
    service.shutdown(); 
  } 
} 

class Task implements Runnable { 
  private int taskId; 
  
  public Task(int id) { this.taskId = id; } 
  
  public void run() { 
    System.out.println("Starting task " + taskId); 
    try { 
      Thread.sleep(100); 
    } 
    catch (InterruptedException e) { 
      e.printStackTrace(); 
    } 
    
    System.out.println("Task executed asynchronously " + taskId); 
  } 
}


List<Callable<Integer>> tasks = Arrays.asList(() -> 1, () -> 2, () -> 3);
List<Future<Integer>> futures = executor.invokeAll(tasks);
for (Future<Integer> future : futures) {
    System.out.println("Result: " + future.get());
}

List<Runnable> pendingTasks = executor.shutdownNow();

Future<String> future = executor.submit(() -> {
    // Task logic
    return "42";
});
Set<Callable<String>> callables = new HashSet<>();

boolean terminated = executor.awaitTermination(10, TimeUnit.SECONDS);
if (terminated) {
    System.out.println("All tasks have completed execution");
} else {
    System.out.println("Timeout occurred before all tasks completed");
}

class Calculator {
   int add(int a, int b) {
       return a + b;
   }
   double add(double a, double b) {
       return a + b;
   }
}



for (int i = 0; i < 5; i++) {
   if (i == 2) {
       continue;  // Skip iteration when i is 2
   }
   if (i == 4) {
       break;     // Exit loop when i is 4
   }
   System.out.println(i);
}





import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Main {
   public static void main(String[] args) {
       // Create a fixed thread pool with 10 threads
       ExecutorService executor = Executors.newFixedThreadPool(10);

       // List to hold Future objects
       List<Future<Integer>> futures = new ArrayList<>();

       // Submit tasks to the executor
       for (int i = 0; i < 10; i++) {
           int[] numbers = {i, i + 1, i + 2};
           SumTask task = new SumTask(numbers);
           futures.add(executor.submit(task));
       }

       // Retrieve and print the results
       for (Future<Integer> future : futures) {
           try {
                Integer result = future.get(); // Blocking call, waits for the result
                System.out.println("Result: " + result);
           } catch (Exception e) {
               e.printStackTrace();
           }
       }

       // Shutdown the executor
       executor.shutdown();
   }
}


ExecutorService threadPool = Executors.newFixedThreadPool(100);
try {
    for (Request request : incomingRequests) {
        threadPool.execute(() -> {
            processRequest(request);
            generateResponse(request);
        });
    }
} finally {
    threadPool.shutdown();
    if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
        threadPool.shutdownNow();
    }
}

       Thread threadA = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                System.out.println("‰ªªÂä°A: " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
					 e.printStackTrace();
                }
            }
        });

import java.util.concurrent.Callable;

public class SumTask implements Callable<Integer> {
    private int[] numbers;

    public SumTask(int[] numbers) {
        this.numbers = numbers;
    } 

@Override
public Integer call() throws Exception {
    int sum = 0;
    for (int number : numbers) {
        sum += number;
    }
    return sum;
  }
}


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureExample {
 public static void main(String[] args) {
  // Create an array of numbers to sum up
  int[] numbers = {1, 2, 3, 4, 5};

  // Create a SumTask
  SumTask task = new SumTask(numbers);

  // Create an ExecutorService
  ExecutorService executor = Executors.newSingleThreadExecutor();

  // Submit the task to the executor
  Future<Integer> future = executor.submit(task);

  try {
   // Get the result of the computation
   Integer result = future.get();
   System.out.println("Sum: " + result);
} catch (Exception e) {
   e.printStackTrace();
} finally {
  // Shut down the executor
  executor.shutdown();
  }
 }
}


Future<Integer> future = executor.submit(task);
if (!future.isDone()) {
  future.cancel(true);
}


Future<Integer> future = executor.submit(task);
try {
  Integer result = future.get(1, TimeUnit.SECONDS);
  System.out.println("Sum: " + result);
} catch (TimeoutException e) {
  System.out.println("Task timed out");
}






ExecutorService executorService = Executors.newFixedThreadPool(5);
Future<String> f1 = executorService.submit(getCallable("Task 1"));
String s1 = f1.get();
System.out.println(s1);
executorService.shutdown();

 private static Callable<String> getCallable(String taskName) {
        return () -> "Task:::" + taskName + " => Thread:::" + Thread.currentThread().getName();
    }
	
	
Stream<Integer> evenNumbersUntil100 = Stream.iterate(0, n -> n <= 100, n -> n + 2);
evenNumbersUntil100.forEach(System.out::println);


try {
    String result = CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(10000);
            return "‰ªªÂä°ÂÆåÊàê";
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return "‰ªªÂä°‰∏≠Êñ≠";
        }
    }).get(5, TimeUnit.SECONDS); 

    System.out.println(result);
} catch (TimeoutException e) {
    System.out.println("‰ªªÂä°Ë∂ÖÊó∂");
}


CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(10000);
        return "‰ªªÂä°ÂÆåÊàê";
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return "‰ªªÂä°‰∏≠Êñ≠";
    }
}).orTimeout(5, TimeUnit.SECONDS)
  .exceptionally(ex -> {
      if (ex instanceof TimeoutException) {
          return "‰ªªÂä°Ë∂ÖÊó∂ÔºåËøîÂõûÈªòËÆ§ÂÄº";
      }
      return "ÂÖ∂‰ªñÂºÇÂ∏∏: " + ex.getMessage();
  });

String result = future.join();
System.out.println(result);



Use different thread pools for different stages :
ExecutorService computeExecutor = Executors.newFixedThreadPool(2);
ExecutorService processExecutor = Executors.newFixedThreadPool(2);

List<CompletableFuture<String>> futures = new ArrayList<>();

for (int i = 0; i < 10; i++) {
    int taskId = i;
    futures.add(CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(1000);
            return "‰ªªÂä°" + taskId + "ÂÆåÊàê";
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }, computeExecutor).thenApplyAsync(result -> {
        try {
            Thread.sleep(1000);
            return result + " Â§ÑÁêÜÂÆåÊàê";
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }, processExecutor));
}

CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
computeExecutor.shutdown();
processExecutor.shutdown();


Use an unbounded thread pool or a thread pool with sufficient capacity (use with caution, resources may be exhausted):
ExecutorService executor = Executors.newFixedThreadPool(20);


Use the method without the Async suffix to execute subsequent stages in the same thread :
futures.add(CompletableFuture.supplyAsync(() -> {
    return "‰ªªÂä°ÂÆåÊàê";
}, executor).thenApply(result -> { 
    return result + " Â§ÑÁêÜÂÆåÊàê";
}));


CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(10000);
        return "‰ªªÂä°ÂÆåÊàê";
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return "‰ªªÂä°‰∏≠Êñ≠";
    }
}).orTimeout(5, TimeUnit.SECONDS) // 5ÁßíÂêéÊäõÂá∫ÂºÇÂ∏∏
  .exceptionally(ex -> {
      if (ex instanceof TimeoutException) {
          return "‰ªªÂä°Ë∂ÖÊó∂ÔºåËøîÂõûÈªòËÆ§ÂÄº";
      }
      return "ÂÖ∂‰ªñÂºÇÂ∏∏: " + ex.getMessage();
  });

String result = future.join();
System.out.println(result);



interface	Features
Runnable	No return value
Callable	    Has a return value
Future	    Asynchronous tasks





public class SequenceGenerator implements Runnable {

    private NumbersGenerator numbersGenerator;
    private int remainder;

    public SequenceGenerator(NumbersGenerator numbersGenerator, int remainder) {
        this.numbersGenerator = numbersGenerator;
        this.remainder = remainder;
    }

    @Override
    public void run() {
        numbersGenerator.printNumber(this.remainder);
    }
}
public class NumbersGenerator {
    private int currNumber = 1;
    private final int numOfThreads;
    private final int totalNumbersInSeq;

    public NumbersGenerator(int numOfThreads, int totalNumbersInSeq) {
        this.numOfThreads = numOfThreads;
        this.totalNumbersInSeq = totalNumbersInSeq;
    }

    public synchronized void printNumberV1(int remainder) {
        while (true) {
            // Exit condition first: end processing if all numbers are printed
            if (currNumber > totalNumbersInSeq) {
                notifyAll(); // Wake up any waiting threads so they can exit too
                break;
            }

            // Check if it's this thread's turn to print
            if ((currNumber - 1) % numOfThreads != remainder) {
                try {
                    wait(); // Not this thread's turn, wait
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            } else {
                // It's this thread's turn
                System.out.println(Thread.currentThread().getName() + " : " + currNumber);
                currNumber++;         // Increment the shared number
                notifyAll();          // Wake up all threads to recheck their turn
            }
        }
        // Optional: log thread termination
        System.out.println(Thread.currentThread().getName() + " finished.");
    }

    public synchronized void printNumberV2(int remainder) {
            while(true) {
			   while (currNumber <= totalNumbersInSeq && (currNumber - 1) % numOfThreads != remainder) {
                    try {
                        wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt(); e.printStackTrace();
						return; // gracefully exit
                    }
                }
				if (currNumber > totalNumbersInSeq) {
                    notifyAll(); // prevent deadlock // Important to wake up others waiting
                    break;
                }
                System.out.println(Thread.currentThread().getName() + " : " + currNumber);
				currNumber++;
                notifyAll();
            }
    }
}
public class SequenceGeneratorTester {
    private static final int NUMBER_OF_THREADS = 3;
    private static final int TOTAL_NUMBERS_IN_SEQ = 10;

    public static void main(String[] args) {
        NumbersGenerator numbersGenerator = new NumbersGenerator(NUMBER_OF_THREADS, TOTAL_NUMBERS_IN_SEQ);

        for (int i = 0; i < NUMBER_OF_THREADS; i++) {
		    final int threadId = i;
            new Thread(new SequenceGenerator(numbersGenerator, threadId), "THREAD-" + threadId).start();
        }
    }
}


Step	currNumber	Thread	(currNumber - 1) % 3 == remainder	Action	Output
1		1		T0	(0 % 3) == 0 ‚Üí ‚úÖ	Prints	THREAD-0 : 1
2		2		T1	(1 % 3) == 1 ‚Üí ‚úÖ	Prints	THREAD-1 : 2
3		3		T2	(2 % 3) == 2 ‚Üí ‚úÖ	Prints	THREAD-2 : 3
4		4		T0	(3 % 3) == 0 ‚Üí ‚úÖ	Prints	THREAD-0 : 4
5	    5		T1	(4 % 3) == 1 ‚Üí ‚úÖ	Prints	THREAD-1 : 5
6	    6		T2	(5 % 3) == 2 ‚Üí ‚úÖ	Prints	THREAD-2 : 6
7	    7		T0	(6 % 3) == 0 ‚Üí ‚úÖ	Prints	THREAD-0 : 7
8	    8		T1	(7 % 3) == 1 ‚Üí ‚úÖ	Prints	THREAD-1 : 8
9	    9		T2	(8 % 3) == 2 ‚Üí ‚úÖ	Prints	THREAD-2 : 9
10	10	T0	(9 % 3) == 0 ‚Üí ‚úÖ	Prints	THREAD-0 : 10
11	11	All	(10 > 10)	Exit condition	Threads stop gracefully



public class SequenceGenerator {

    private static final Object lock = new Object();
    private static int NO_OF_THREADS = 3;
    private static int PRINT_NUMBERS_UPTO = 10;
    private static int counter = 1;

    public static void main(String[] args) {
        // Creating threads
        for (int i = 1; i <= NO_OF_THREADS; i++) {
            new Thread(new Generator(i % NO_OF_THREADS), "T" + i).start();
        }
    }

    static class Generator implements Runnable {

        private int remainder;

        Generator(int remainder) {
            this.remainder = remainder;
        }

        @Override
        public void run() {
            while (counter <= PRINT_NUMBERS_UPTO) {
                synchronized (lock) {
                    while (counter % NO_OF_THREADS != remainder) {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    if (counter % NO_OF_THREADS == remainder &&  counter <= PRINT_NUMBERS_UPTO) {
                        System.out.print(Thread.currentThread().getName() + "-" + counter + "\t");
                    }
                    counter++;
                    lock.notifyAll();
                }

            }
        }

    }

}

private void shutdownExecutor(ExecutorService executor) {
    executor.shutdown();
    try {
        if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
            executor.shutdownNow();
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                System.err.println("Executor did not terminate.");
            }
        }
    } catch (InterruptedException e) {
        executor.shutdownNow();
        Thread.currentThread().interrupt();
    }
}








public class EvenOddPrinter {
    private int count = 1;
    private static final int MAX_COUNT = 20;
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition even = lock.newCondition();
    private final Condition odd = lock.newCondition();

    public void printOdd() {
        while (true) {
            try {
                lock.lock();
                while (count <= MAX_COUNT && count % 2 == 0) {
                    odd.await();
                }
                if (count > MAX_COUNT) {
                    even.signal(); // Wake the even thread in case it's waiting
                    break;
                }				
                System.out.println("Odd: " + count);
                count++;
                even.signal();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                lock.unlock();
            }
        }
    }

    public void printEven() {
        while (true) {
            try {
                lock.lock();
                while (count <= MAX_COUNT && count % 2 != 0) {
                    even.await();
                }
                if (count > MAX_COUNT) {
                    odd.signal(); // Wake the odd thread in case it's waiting
                    break;
                }				
                System.out.println("Even: " + count);
                count++;
                odd.signal();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        EvenOddPrinter printer = new EvenOddPrinter();
        ExecutorService executor = Executors.newFixedThreadPool(2);

        executor.submit(printer::printOdd);
        executor.submit(printer::printEven);

        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);
        System.out.println("All tasks completed.");
    }
}
	
	
	
	
	
	
	
	
	public static boolean isPalindrome(int num) {
        int originalNumber = num;  // Store the original number
        int reversedNumber = 0;    // To hold the reversed number
        
        // Reverse the number
        while (num != 0) {
            int digit = num % 10;      // Extract the last digit
            reversedNumber = reversedNumber * 10 + digit;  // Append the digit to the reversed number
            num = num / 10;            // Remove the last digit from the number
        }
        
        // Check if the reversed number is equal to the original number
        return originalNumber == reversedNumber;
    }
	
	     int originalNumber = number;
        int sumOfCubes = 0;

        // Calculate the sum of cubes of digits
        while (number > 0) {
            int digit = number % 10;
            number = number / 10;
            sumOfCubes += digit * digit * digit;
        }
	
	
    public static boolean isPrime(int num) {
        // Handle edge cases
        if (num <= 1) {
            return false;
        }

        // Check for divisibility from 2 up to num/2
        for(int i = 2; i <= num / 2; i++) {
            if(num % i == 0) {
                return false; // num is divisible by i, so it's not a prime number
            }
        }
        
        return true; // num is not divisible by any number other than 1 and itself
    }	
	
	
	
	
	
	  // Convert strings to character arrays
        char[] arr1 = str1.toCharArray();
        char[] arr2 = str2.toCharArray();
        
        // Sort character arrays
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        
        // Compare sorted arrays
        boolean result = Arrays.equals(arr1, arr2);
		
		
		
		
public class FibonacciMemoization {
    private static Map<Integer, Integer> memo = new HashMap<>();

    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        int result = fibonacci(n - 1) + fibonacci(n - 2);
        memo.put(n, result);
        return result;
    }

    public static void main(String[] args) {
        int n = 10;
        System.out.println(fibonacci(n)); // Output: 55
    }
}

public class FibonacciMemoization {  
    int[] cache;

    FibonacciMemoization(int[] cache){
        this.cache = cache;
    }

    int fibonacci(int n) {
        if (cache[n] == 0) {
            if (n < 2) cache[n] = n;
            else cache[n] = fibonacci(n-1) + fibonacci( n-2);
        }

        return cache[n];
    }

    public static void main(String[] args) {
        int n = 10;
        System.out.println(new FibonacciMemoization(new int[n+1]).fibonacci(n));
    }
}


public class FibonacciTabular {  
    int fibonacci(int n) {
	if (n <= 1) {
            return n;
        }
        int[] cache = new int[n+1];
        cache[0] = 0;
        cache[1] = 1;

        for (int i = 2; i <= n; i++) {
            cache[i] = cache[i-1] + cache[i-2];
        }

        return cache[n];
    }

    public static void main(String[] args) {
        System.out.println(new FibonacciTabular().fibonacci(10));
    }
}



public class LoadBalancerDynamicProgramming {

    public static void main(String[] args) {
        int[] serverCapacities = {10, 15, 20};
        int totalWorkload = 30;

        int optimalDistribution = findOptimalDistribution(serverCapacities, totalWorkload);

        System.out.println("Optimal Distribution: " + (optimalDistribution == Integer.MAX_VALUE ? "No valid distribution" : optimalDistribution));
    }

    private static int findOptimalDistribution(int[] serverCapacities, int totalWorkload) {
        int[] dp = new int[totalWorkload + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        for (int i = 1; i <= totalWorkload; i++) {
            for (int capacity : serverCapacities) {
                if (i >= capacity && dp[i - capacity] != Integer.MAX_VALUE) {
                    dp[i] = Math.min(dp[i], 1 + dp[i - capacity]);
                }
            }
        }

        return dp[totalWorkload];
    }
}		